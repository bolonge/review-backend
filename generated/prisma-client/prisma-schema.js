module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCategory {
  count: Int!
}

type AggregateHate {
  count: Int!
}

type AggregateLike {
  count: Int!
}

type AggregatePhoto {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateSuperCategory {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  categoryName: String!
  product(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  superCategory: SuperCategory
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  categoryName: String!
  product: ProductCreateManyWithoutCategoryInput
  superCategory: SuperCategoryCreateOneWithoutCategoryInput
}

input CategoryCreateManyWithoutSuperCategoryInput {
  create: [CategoryCreateWithoutSuperCategoryInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneWithoutProductInput {
  create: CategoryCreateWithoutProductInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductInput {
  id: ID
  categoryName: String!
  superCategory: SuperCategoryCreateOneWithoutCategoryInput
}

input CategoryCreateWithoutSuperCategoryInput {
  id: ID
  categoryName: String!
  product: ProductCreateManyWithoutCategoryInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  categoryName_ASC
  categoryName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  categoryName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  categoryName: String
  categoryName_not: String
  categoryName_in: [String!]
  categoryName_not_in: [String!]
  categoryName_lt: String
  categoryName_lte: String
  categoryName_gt: String
  categoryName_gte: String
  categoryName_contains: String
  categoryName_not_contains: String
  categoryName_starts_with: String
  categoryName_not_starts_with: String
  categoryName_ends_with: String
  categoryName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  categoryName: String
  product: ProductUpdateManyWithoutCategoryInput
  superCategory: SuperCategoryUpdateOneWithoutCategoryInput
}

input CategoryUpdateManyDataInput {
  categoryName: String
}

input CategoryUpdateManyMutationInput {
  categoryName: String
}

input CategoryUpdateManyWithoutSuperCategoryInput {
  create: [CategoryCreateWithoutSuperCategoryInput!]
  delete: [CategoryWhereUniqueInput!]
  connect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutSuperCategoryInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutSuperCategoryInput!]
  deleteMany: [CategoryScalarWhereInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput!
  data: CategoryUpdateManyDataInput!
}

input CategoryUpdateOneRequiredWithoutProductInput {
  create: CategoryCreateWithoutProductInput
  update: CategoryUpdateWithoutProductDataInput
  upsert: CategoryUpsertWithoutProductInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductDataInput {
  categoryName: String
  superCategory: SuperCategoryUpdateOneWithoutCategoryInput
}

input CategoryUpdateWithoutSuperCategoryDataInput {
  categoryName: String
  product: ProductUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithWhereUniqueWithoutSuperCategoryInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutSuperCategoryDataInput!
}

input CategoryUpsertWithoutProductInput {
  update: CategoryUpdateWithoutProductDataInput!
  create: CategoryCreateWithoutProductInput!
}

input CategoryUpsertWithWhereUniqueWithoutSuperCategoryInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutSuperCategoryDataInput!
  create: CategoryCreateWithoutSuperCategoryInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  categoryName: String
  categoryName_not: String
  categoryName_in: [String!]
  categoryName_not_in: [String!]
  categoryName_lt: String
  categoryName_lte: String
  categoryName_gt: String
  categoryName_gte: String
  categoryName_contains: String
  categoryName_not_contains: String
  categoryName_starts_with: String
  categoryName_not_starts_with: String
  categoryName_ends_with: String
  categoryName_not_ends_with: String
  product_every: ProductWhereInput
  product_some: ProductWhereInput
  product_none: ProductWhereInput
  superCategory: SuperCategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

type Hate {
  id: ID!
  user: User
  review: Review
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HateConnection {
  pageInfo: PageInfo!
  edges: [HateEdge]!
  aggregate: AggregateHate!
}

input HateCreateInput {
  id: ID
  user: UserCreateOneWithoutMyHateInput
  review: ReviewCreateOneWithoutHatesInput
}

input HateCreateManyWithoutReviewInput {
  create: [HateCreateWithoutReviewInput!]
  connect: [HateWhereUniqueInput!]
}

input HateCreateManyWithoutUserInput {
  create: [HateCreateWithoutUserInput!]
  connect: [HateWhereUniqueInput!]
}

input HateCreateWithoutReviewInput {
  id: ID
  user: UserCreateOneWithoutMyHateInput
}

input HateCreateWithoutUserInput {
  id: ID
  review: ReviewCreateOneWithoutHatesInput
}

type HateEdge {
  node: Hate!
  cursor: String!
}

enum HateOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HatePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HateScalarWhereInput!]
  OR: [HateScalarWhereInput!]
  NOT: [HateScalarWhereInput!]
}

type HateSubscriptionPayload {
  mutation: MutationType!
  node: Hate
  updatedFields: [String!]
  previousValues: HatePreviousValues
}

input HateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HateWhereInput
  AND: [HateSubscriptionWhereInput!]
  OR: [HateSubscriptionWhereInput!]
  NOT: [HateSubscriptionWhereInput!]
}

input HateUpdateInput {
  user: UserUpdateOneWithoutMyHateInput
  review: ReviewUpdateOneWithoutHatesInput
}

input HateUpdateManyWithoutReviewInput {
  create: [HateCreateWithoutReviewInput!]
  delete: [HateWhereUniqueInput!]
  connect: [HateWhereUniqueInput!]
  set: [HateWhereUniqueInput!]
  disconnect: [HateWhereUniqueInput!]
  update: [HateUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [HateUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [HateScalarWhereInput!]
}

input HateUpdateManyWithoutUserInput {
  create: [HateCreateWithoutUserInput!]
  delete: [HateWhereUniqueInput!]
  connect: [HateWhereUniqueInput!]
  set: [HateWhereUniqueInput!]
  disconnect: [HateWhereUniqueInput!]
  update: [HateUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [HateUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [HateScalarWhereInput!]
}

input HateUpdateWithoutReviewDataInput {
  user: UserUpdateOneWithoutMyHateInput
}

input HateUpdateWithoutUserDataInput {
  review: ReviewUpdateOneWithoutHatesInput
}

input HateUpdateWithWhereUniqueWithoutReviewInput {
  where: HateWhereUniqueInput!
  data: HateUpdateWithoutReviewDataInput!
}

input HateUpdateWithWhereUniqueWithoutUserInput {
  where: HateWhereUniqueInput!
  data: HateUpdateWithoutUserDataInput!
}

input HateUpsertWithWhereUniqueWithoutReviewInput {
  where: HateWhereUniqueInput!
  update: HateUpdateWithoutReviewDataInput!
  create: HateCreateWithoutReviewInput!
}

input HateUpsertWithWhereUniqueWithoutUserInput {
  where: HateWhereUniqueInput!
  update: HateUpdateWithoutUserDataInput!
  create: HateCreateWithoutUserInput!
}

input HateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  review: ReviewWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HateWhereInput!]
  OR: [HateWhereInput!]
  NOT: [HateWhereInput!]
}

input HateWhereUniqueInput {
  id: ID
}

type Like {
  id: ID!
  user: User
  review: Review
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LikeConnection {
  pageInfo: PageInfo!
  edges: [LikeEdge]!
  aggregate: AggregateLike!
}

input LikeCreateInput {
  id: ID
  user: UserCreateOneWithoutMyLikeInput
  review: ReviewCreateOneWithoutLikesInput
}

input LikeCreateManyWithoutReviewInput {
  create: [LikeCreateWithoutReviewInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutReviewInput {
  id: ID
  user: UserCreateOneWithoutMyLikeInput
}

input LikeCreateWithoutUserInput {
  id: ID
  review: ReviewCreateOneWithoutLikesInput
}

type LikeEdge {
  node: Like!
  cursor: String!
}

enum LikeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LikePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeScalarWhereInput!]
  OR: [LikeScalarWhereInput!]
  NOT: [LikeScalarWhereInput!]
}

type LikeSubscriptionPayload {
  mutation: MutationType!
  node: Like
  updatedFields: [String!]
  previousValues: LikePreviousValues
}

input LikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LikeWhereInput
  AND: [LikeSubscriptionWhereInput!]
  OR: [LikeSubscriptionWhereInput!]
  NOT: [LikeSubscriptionWhereInput!]
}

input LikeUpdateInput {
  user: UserUpdateOneWithoutMyLikeInput
  review: ReviewUpdateOneWithoutLikesInput
}

input LikeUpdateManyWithoutReviewInput {
  create: [LikeCreateWithoutReviewInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateWithoutReviewDataInput {
  user: UserUpdateOneWithoutMyLikeInput
}

input LikeUpdateWithoutUserDataInput {
  review: ReviewUpdateOneWithoutLikesInput
}

input LikeUpdateWithWhereUniqueWithoutReviewInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutReviewDataInput!
}

input LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutUserDataInput!
}

input LikeUpsertWithWhereUniqueWithoutReviewInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutReviewDataInput!
  create: LikeCreateWithoutReviewInput!
}

input LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutUserDataInput!
  create: LikeCreateWithoutUserInput!
}

input LikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  review: ReviewWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
}

input LikeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createHate(data: HateCreateInput!): Hate!
  updateHate(data: HateUpdateInput!, where: HateWhereUniqueInput!): Hate
  upsertHate(where: HateWhereUniqueInput!, create: HateCreateInput!, update: HateUpdateInput!): Hate!
  deleteHate(where: HateWhereUniqueInput!): Hate
  deleteManyHates(where: HateWhereInput): BatchPayload!
  createLike(data: LikeCreateInput!): Like!
  updateLike(data: LikeUpdateInput!, where: LikeWhereUniqueInput!): Like
  upsertLike(where: LikeWhereUniqueInput!, create: LikeCreateInput!, update: LikeUpdateInput!): Like!
  deleteLike(where: LikeWhereUniqueInput!): Like
  deleteManyLikes(where: LikeWhereInput): BatchPayload!
  createPhoto(data: PhotoCreateInput!): Photo!
  updatePhoto(data: PhotoUpdateInput!, where: PhotoWhereUniqueInput!): Photo
  updateManyPhotos(data: PhotoUpdateManyMutationInput!, where: PhotoWhereInput): BatchPayload!
  upsertPhoto(where: PhotoWhereUniqueInput!, create: PhotoCreateInput!, update: PhotoUpdateInput!): Photo!
  deletePhoto(where: PhotoWhereUniqueInput!): Photo
  deleteManyPhotos(where: PhotoWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createSuperCategory(data: SuperCategoryCreateInput!): SuperCategory!
  updateSuperCategory(data: SuperCategoryUpdateInput!, where: SuperCategoryWhereUniqueInput!): SuperCategory
  updateManySuperCategories(data: SuperCategoryUpdateManyMutationInput!, where: SuperCategoryWhereInput): BatchPayload!
  upsertSuperCategory(where: SuperCategoryWhereUniqueInput!, create: SuperCategoryCreateInput!, update: SuperCategoryUpdateInput!): SuperCategory!
  deleteSuperCategory(where: SuperCategoryWhereUniqueInput!): SuperCategory
  deleteManySuperCategories(where: SuperCategoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Photo {
  id: ID!
  url: String!
  review: Review
  product: Product
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoConnection {
  pageInfo: PageInfo!
  edges: [PhotoEdge]!
  aggregate: AggregatePhoto!
}

input PhotoCreateInput {
  id: ID
  url: String!
  review: ReviewCreateOneWithoutReviewPhotosInput
  product: ProductCreateOneWithoutProductPhotosInput
}

input PhotoCreateManyWithoutProductInput {
  create: [PhotoCreateWithoutProductInput!]
  connect: [PhotoWhereUniqueInput!]
}

input PhotoCreateManyWithoutReviewInput {
  create: [PhotoCreateWithoutReviewInput!]
  connect: [PhotoWhereUniqueInput!]
}

input PhotoCreateWithoutProductInput {
  id: ID
  url: String!
  review: ReviewCreateOneWithoutReviewPhotosInput
}

input PhotoCreateWithoutReviewInput {
  id: ID
  url: String!
  product: ProductCreateOneWithoutProductPhotosInput
}

type PhotoEdge {
  node: Photo!
  cursor: String!
}

enum PhotoOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhotoPreviousValues {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhotoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoScalarWhereInput!]
  OR: [PhotoScalarWhereInput!]
  NOT: [PhotoScalarWhereInput!]
}

type PhotoSubscriptionPayload {
  mutation: MutationType!
  node: Photo
  updatedFields: [String!]
  previousValues: PhotoPreviousValues
}

input PhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhotoWhereInput
  AND: [PhotoSubscriptionWhereInput!]
  OR: [PhotoSubscriptionWhereInput!]
  NOT: [PhotoSubscriptionWhereInput!]
}

input PhotoUpdateInput {
  url: String
  review: ReviewUpdateOneWithoutReviewPhotosInput
  product: ProductUpdateOneWithoutProductPhotosInput
}

input PhotoUpdateManyDataInput {
  url: String
}

input PhotoUpdateManyMutationInput {
  url: String
}

input PhotoUpdateManyWithoutProductInput {
  create: [PhotoCreateWithoutProductInput!]
  delete: [PhotoWhereUniqueInput!]
  connect: [PhotoWhereUniqueInput!]
  set: [PhotoWhereUniqueInput!]
  disconnect: [PhotoWhereUniqueInput!]
  update: [PhotoUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [PhotoUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [PhotoScalarWhereInput!]
  updateMany: [PhotoUpdateManyWithWhereNestedInput!]
}

input PhotoUpdateManyWithoutReviewInput {
  create: [PhotoCreateWithoutReviewInput!]
  delete: [PhotoWhereUniqueInput!]
  connect: [PhotoWhereUniqueInput!]
  set: [PhotoWhereUniqueInput!]
  disconnect: [PhotoWhereUniqueInput!]
  update: [PhotoUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [PhotoUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [PhotoScalarWhereInput!]
  updateMany: [PhotoUpdateManyWithWhereNestedInput!]
}

input PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput!
  data: PhotoUpdateManyDataInput!
}

input PhotoUpdateWithoutProductDataInput {
  url: String
  review: ReviewUpdateOneWithoutReviewPhotosInput
}

input PhotoUpdateWithoutReviewDataInput {
  url: String
  product: ProductUpdateOneWithoutProductPhotosInput
}

input PhotoUpdateWithWhereUniqueWithoutProductInput {
  where: PhotoWhereUniqueInput!
  data: PhotoUpdateWithoutProductDataInput!
}

input PhotoUpdateWithWhereUniqueWithoutReviewInput {
  where: PhotoWhereUniqueInput!
  data: PhotoUpdateWithoutReviewDataInput!
}

input PhotoUpsertWithWhereUniqueWithoutProductInput {
  where: PhotoWhereUniqueInput!
  update: PhotoUpdateWithoutProductDataInput!
  create: PhotoCreateWithoutProductInput!
}

input PhotoUpsertWithWhereUniqueWithoutReviewInput {
  where: PhotoWhereUniqueInput!
  update: PhotoUpdateWithoutReviewDataInput!
  create: PhotoCreateWithoutReviewInput!
}

input PhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  review: ReviewWhereInput
  product: ProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoWhereInput!]
  OR: [PhotoWhereInput!]
  NOT: [PhotoWhereInput!]
}

input PhotoWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  productName: String!
  category: Category!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  productPhotos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo!]
  isPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  reviews: ReviewCreateManyWithoutProductInput
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneWithoutProductPhotosInput {
  create: ProductCreateWithoutProductPhotosInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutReviewsInput {
  create: ProductCreateWithoutReviewsInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutCategoryInput {
  id: ID
  productName: String!
  reviews: ReviewCreateManyWithoutProductInput
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateWithoutProductPhotosInput {
  id: ID
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  reviews: ReviewCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateWithoutReviewsInput {
  id: ID
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  productName_ASC
  productName_DESC
  isPublished_ASC
  isPublished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  productName: String!
  isPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  reviews: ReviewUpdateManyWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateManyDataInput {
  productName: String
  isPublished: Boolean
}

input ProductUpdateManyMutationInput {
  productName: String
  isPublished: Boolean
}

input ProductUpdateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredWithoutReviewsInput {
  create: ProductCreateWithoutReviewsInput
  update: ProductUpdateWithoutReviewsDataInput
  upsert: ProductUpsertWithoutReviewsInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneWithoutProductPhotosInput {
  create: ProductCreateWithoutProductPhotosInput
  update: ProductUpdateWithoutProductPhotosDataInput
  upsert: ProductUpsertWithoutProductPhotosInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutCategoryDataInput {
  productName: String
  reviews: ReviewUpdateManyWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithoutProductPhotosDataInput {
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  reviews: ReviewUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithoutReviewsDataInput {
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCategoryDataInput!
}

input ProductUpsertWithoutProductPhotosInput {
  update: ProductUpdateWithoutProductPhotosDataInput!
  create: ProductCreateWithoutProductPhotosInput!
}

input ProductUpsertWithoutReviewsInput {
  update: ProductUpdateWithoutReviewsDataInput!
  create: ProductCreateWithoutReviewsInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCategoryDataInput!
  create: ProductCreateWithoutCategoryInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  category: CategoryWhereInput
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  productPhotos_every: PhotoWhereInput
  productPhotos_some: PhotoWhereInput
  productPhotos_none: PhotoWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  hate(where: HateWhereUniqueInput!): Hate
  hates(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate]!
  hatesConnection(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HateConnection!
  like(where: LikeWhereUniqueInput!): Like
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like]!
  likesConnection(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LikeConnection!
  photo(where: PhotoWhereUniqueInput!): Photo
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo]!
  photosConnection(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhotoConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  superCategory(where: SuperCategoryWhereUniqueInput!): SuperCategory
  superCategories(where: SuperCategoryWhereInput, orderBy: SuperCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SuperCategory]!
  superCategoriesConnection(where: SuperCategoryWhereInput, orderBy: SuperCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SuperCategoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  user: User
  product: Product!
  text: String!
  rating: Int!
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  hates(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate!]
  reviewPhotos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Int!
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateManyWithoutProductInput {
  create: [ReviewCreateWithoutProductInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutUserInput {
  create: [ReviewCreateWithoutUserInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateOneWithoutHatesInput {
  create: ReviewCreateWithoutHatesInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateOneWithoutLikesInput {
  create: ReviewCreateWithoutLikesInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateOneWithoutReviewPhotosInput {
  create: ReviewCreateWithoutReviewPhotosInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateWithoutHatesInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Int!
  likes: LikeCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutLikesInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Int!
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutProductInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput
  text: String!
  rating: Int!
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutReviewPhotosInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Int!
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
}

input ReviewCreateWithoutUserInput {
  id: ID
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Int!
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  rating_ASC
  rating_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReviewPreviousValues {
  id: ID!
  text: String!
  rating: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  user: UserUpdateOneWithoutMyReviewInput
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Int
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateManyDataInput {
  text: String
  rating: Int
}

input ReviewUpdateManyMutationInput {
  text: String
  rating: Int
}

input ReviewUpdateManyWithoutProductInput {
  create: [ReviewCreateWithoutProductInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithoutUserInput {
  create: [ReviewCreateWithoutUserInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateOneWithoutHatesInput {
  create: ReviewCreateWithoutHatesInput
  update: ReviewUpdateWithoutHatesDataInput
  upsert: ReviewUpsertWithoutHatesInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateOneWithoutLikesInput {
  create: ReviewCreateWithoutLikesInput
  update: ReviewUpdateWithoutLikesDataInput
  upsert: ReviewUpsertWithoutLikesInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateOneWithoutReviewPhotosInput {
  create: ReviewCreateWithoutReviewPhotosInput
  update: ReviewUpdateWithoutReviewPhotosDataInput
  upsert: ReviewUpsertWithoutReviewPhotosInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateWithoutHatesDataInput {
  user: UserUpdateOneWithoutMyReviewInput
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Int
  likes: LikeUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutLikesDataInput {
  user: UserUpdateOneWithoutMyReviewInput
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Int
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutProductDataInput {
  user: UserUpdateOneWithoutMyReviewInput
  text: String
  rating: Int
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutReviewPhotosDataInput {
  user: UserUpdateOneWithoutMyReviewInput
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Int
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutUserDataInput {
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Int
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutProductDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutUserDataInput!
}

input ReviewUpsertWithoutHatesInput {
  update: ReviewUpdateWithoutHatesDataInput!
  create: ReviewCreateWithoutHatesInput!
}

input ReviewUpsertWithoutLikesInput {
  update: ReviewUpdateWithoutLikesDataInput!
  create: ReviewCreateWithoutLikesInput!
}

input ReviewUpsertWithoutReviewPhotosInput {
  update: ReviewUpdateWithoutReviewPhotosDataInput!
  create: ReviewCreateWithoutReviewPhotosInput!
}

input ReviewUpsertWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutProductDataInput!
  create: ReviewCreateWithoutProductInput!
}

input ReviewUpsertWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutUserDataInput!
  create: ReviewCreateWithoutUserInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  product: ProductWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  likes_every: LikeWhereInput
  likes_some: LikeWhereInput
  likes_none: LikeWhereInput
  hates_every: HateWhereInput
  hates_some: HateWhereInput
  hates_none: HateWhereInput
  reviewPhotos_every: PhotoWhereInput
  reviewPhotos_some: PhotoWhereInput
  reviewPhotos_none: PhotoWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Subscription {
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  hate(where: HateSubscriptionWhereInput): HateSubscriptionPayload
  like(where: LikeSubscriptionWhereInput): LikeSubscriptionPayload
  photo(where: PhotoSubscriptionWhereInput): PhotoSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  superCategory(where: SuperCategorySubscriptionWhereInput): SuperCategorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type SuperCategory {
  id: ID!
  superCategoryName: String!
  category(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SuperCategoryConnection {
  pageInfo: PageInfo!
  edges: [SuperCategoryEdge]!
  aggregate: AggregateSuperCategory!
}

input SuperCategoryCreateInput {
  id: ID
  superCategoryName: String!
  category: CategoryCreateManyWithoutSuperCategoryInput
}

input SuperCategoryCreateOneWithoutCategoryInput {
  create: SuperCategoryCreateWithoutCategoryInput
  connect: SuperCategoryWhereUniqueInput
}

input SuperCategoryCreateWithoutCategoryInput {
  id: ID
  superCategoryName: String!
}

type SuperCategoryEdge {
  node: SuperCategory!
  cursor: String!
}

enum SuperCategoryOrderByInput {
  id_ASC
  id_DESC
  superCategoryName_ASC
  superCategoryName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SuperCategoryPreviousValues {
  id: ID!
  superCategoryName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SuperCategorySubscriptionPayload {
  mutation: MutationType!
  node: SuperCategory
  updatedFields: [String!]
  previousValues: SuperCategoryPreviousValues
}

input SuperCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SuperCategoryWhereInput
  AND: [SuperCategorySubscriptionWhereInput!]
  OR: [SuperCategorySubscriptionWhereInput!]
  NOT: [SuperCategorySubscriptionWhereInput!]
}

input SuperCategoryUpdateInput {
  superCategoryName: String
  category: CategoryUpdateManyWithoutSuperCategoryInput
}

input SuperCategoryUpdateManyMutationInput {
  superCategoryName: String
}

input SuperCategoryUpdateOneWithoutCategoryInput {
  create: SuperCategoryCreateWithoutCategoryInput
  update: SuperCategoryUpdateWithoutCategoryDataInput
  upsert: SuperCategoryUpsertWithoutCategoryInput
  delete: Boolean
  disconnect: Boolean
  connect: SuperCategoryWhereUniqueInput
}

input SuperCategoryUpdateWithoutCategoryDataInput {
  superCategoryName: String
}

input SuperCategoryUpsertWithoutCategoryInput {
  update: SuperCategoryUpdateWithoutCategoryDataInput!
  create: SuperCategoryCreateWithoutCategoryInput!
}

input SuperCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  superCategoryName: String
  superCategoryName_not: String
  superCategoryName_in: [String!]
  superCategoryName_not_in: [String!]
  superCategoryName_lt: String
  superCategoryName_lte: String
  superCategoryName_gt: String
  superCategoryName_gte: String
  superCategoryName_contains: String
  superCategoryName_not_contains: String
  superCategoryName_starts_with: String
  superCategoryName_not_starts_with: String
  superCategoryName_ends_with: String
  superCategoryName_not_ends_with: String
  category_every: CategoryWhereInput
  category_some: CategoryWhereInput
  category_none: CategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SuperCategoryWhereInput!]
  OR: [SuperCategoryWhereInput!]
  NOT: [SuperCategoryWhereInput!]
}

input SuperCategoryWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean!
  myReview(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  myLike(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  myHate(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate!]
  loginSecret: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean
  myReview: ReviewCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateOneWithoutMyHateInput {
  create: UserCreateWithoutMyHateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyLikeInput {
  create: UserCreateWithoutMyLikeInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyReviewInput {
  create: UserCreateWithoutMyReviewInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutMyHateInput {
  id: ID
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean
  myReview: ReviewCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateWithoutMyLikeInput {
  id: ID
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean
  myReview: ReviewCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateWithoutMyReviewInput {
  id: ID
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean
  myLike: LikeCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  nickName_ASC
  nickName_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  bio_ASC
  bio_DESC
  loginSecret_ASC
  loginSecret_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  nickName: String!
  phone: String!
  email: String!
  bio: Boolean!
  loginSecret: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  nickName: String
  phone: String
  email: String
  bio: Boolean
  myReview: ReviewUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateManyMutationInput {
  nickName: String
  phone: String
  email: String
  bio: Boolean
  loginSecret: String
}

input UserUpdateOneWithoutMyHateInput {
  create: UserCreateWithoutMyHateInput
  update: UserUpdateWithoutMyHateDataInput
  upsert: UserUpsertWithoutMyHateInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMyLikeInput {
  create: UserCreateWithoutMyLikeInput
  update: UserUpdateWithoutMyLikeDataInput
  upsert: UserUpsertWithoutMyLikeInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMyReviewInput {
  create: UserCreateWithoutMyReviewInput
  update: UserUpdateWithoutMyReviewDataInput
  upsert: UserUpsertWithoutMyReviewInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutMyHateDataInput {
  nickName: String
  phone: String
  email: String
  bio: Boolean
  myReview: ReviewUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateWithoutMyLikeDataInput {
  nickName: String
  phone: String
  email: String
  bio: Boolean
  myReview: ReviewUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateWithoutMyReviewDataInput {
  nickName: String
  phone: String
  email: String
  bio: Boolean
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpsertWithoutMyHateInput {
  update: UserUpdateWithoutMyHateDataInput!
  create: UserCreateWithoutMyHateInput!
}

input UserUpsertWithoutMyLikeInput {
  update: UserUpdateWithoutMyLikeDataInput!
  create: UserCreateWithoutMyLikeInput!
}

input UserUpsertWithoutMyReviewInput {
  update: UserUpdateWithoutMyReviewDataInput!
  create: UserCreateWithoutMyReviewInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nickName: String
  nickName_not: String
  nickName_in: [String!]
  nickName_not_in: [String!]
  nickName_lt: String
  nickName_lte: String
  nickName_gt: String
  nickName_gte: String
  nickName_contains: String
  nickName_not_contains: String
  nickName_starts_with: String
  nickName_not_starts_with: String
  nickName_ends_with: String
  nickName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  bio: Boolean
  bio_not: Boolean
  myReview_every: ReviewWhereInput
  myReview_some: ReviewWhereInput
  myReview_none: ReviewWhereInput
  myLike_every: LikeWhereInput
  myLike_some: LikeWhereInput
  myLike_none: LikeWhereInput
  myHate_every: HateWhereInput
  myHate_some: HateWhereInput
  myHate_none: HateWhereInput
  loginSecret: String
  loginSecret_not: String
  loginSecret_in: [String!]
  loginSecret_not_in: [String!]
  loginSecret_lt: String
  loginSecret_lte: String
  loginSecret_gt: String
  loginSecret_gte: String
  loginSecret_contains: String
  loginSecret_not_contains: String
  loginSecret_starts_with: String
  loginSecret_not_starts_with: String
  loginSecret_ends_with: String
  loginSecret_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  nickName: String
  phone: String
  email: String
}
`
      }
    