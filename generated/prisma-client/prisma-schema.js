module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBlackList {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateHate {
  count: Int!
}

type AggregateKeyword {
  count: Int!
}

type AggregateLike {
  count: Int!
}

type AggregatePhoto {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateSuperCategory {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BlackList {
  id: ID!
  email: String!
}

type BlackListConnection {
  pageInfo: PageInfo!
  edges: [BlackListEdge]!
  aggregate: AggregateBlackList!
}

input BlackListCreateInput {
  id: ID
  email: String!
}

type BlackListEdge {
  node: BlackList!
  cursor: String!
}

enum BlackListOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
}

type BlackListPreviousValues {
  id: ID!
  email: String!
}

type BlackListSubscriptionPayload {
  mutation: MutationType!
  node: BlackList
  updatedFields: [String!]
  previousValues: BlackListPreviousValues
}

input BlackListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BlackListWhereInput
  AND: [BlackListSubscriptionWhereInput!]
  OR: [BlackListSubscriptionWhereInput!]
  NOT: [BlackListSubscriptionWhereInput!]
}

input BlackListUpdateInput {
  email: String
}

input BlackListUpdateManyMutationInput {
  email: String
}

input BlackListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [BlackListWhereInput!]
  OR: [BlackListWhereInput!]
  NOT: [BlackListWhereInput!]
}

input BlackListWhereUniqueInput {
  id: ID
}

type Category {
  id: ID!
  categoryName: String!
  product(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  superCategory: SuperCategory
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  categoryName: String!
  product: ProductCreateManyWithoutCategoryInput
  superCategory: SuperCategoryCreateOneWithoutCategoryInput
}

input CategoryCreateManyWithoutSuperCategoryInput {
  create: [CategoryCreateWithoutSuperCategoryInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneWithoutProductInput {
  create: CategoryCreateWithoutProductInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductInput {
  id: ID
  categoryName: String!
  superCategory: SuperCategoryCreateOneWithoutCategoryInput
}

input CategoryCreateWithoutSuperCategoryInput {
  id: ID
  categoryName: String!
  product: ProductCreateManyWithoutCategoryInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  categoryName_ASC
  categoryName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  categoryName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  categoryName: String
  categoryName_not: String
  categoryName_in: [String!]
  categoryName_not_in: [String!]
  categoryName_lt: String
  categoryName_lte: String
  categoryName_gt: String
  categoryName_gte: String
  categoryName_contains: String
  categoryName_not_contains: String
  categoryName_starts_with: String
  categoryName_not_starts_with: String
  categoryName_ends_with: String
  categoryName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  categoryName: String
  product: ProductUpdateManyWithoutCategoryInput
  superCategory: SuperCategoryUpdateOneWithoutCategoryInput
}

input CategoryUpdateManyDataInput {
  categoryName: String
}

input CategoryUpdateManyMutationInput {
  categoryName: String
}

input CategoryUpdateManyWithoutSuperCategoryInput {
  create: [CategoryCreateWithoutSuperCategoryInput!]
  delete: [CategoryWhereUniqueInput!]
  connect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutSuperCategoryInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutSuperCategoryInput!]
  deleteMany: [CategoryScalarWhereInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput!
  data: CategoryUpdateManyDataInput!
}

input CategoryUpdateOneRequiredWithoutProductInput {
  create: CategoryCreateWithoutProductInput
  update: CategoryUpdateWithoutProductDataInput
  upsert: CategoryUpsertWithoutProductInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductDataInput {
  categoryName: String
  superCategory: SuperCategoryUpdateOneWithoutCategoryInput
}

input CategoryUpdateWithoutSuperCategoryDataInput {
  categoryName: String
  product: ProductUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithWhereUniqueWithoutSuperCategoryInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutSuperCategoryDataInput!
}

input CategoryUpsertWithoutProductInput {
  update: CategoryUpdateWithoutProductDataInput!
  create: CategoryCreateWithoutProductInput!
}

input CategoryUpsertWithWhereUniqueWithoutSuperCategoryInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutSuperCategoryDataInput!
  create: CategoryCreateWithoutSuperCategoryInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  categoryName: String
  categoryName_not: String
  categoryName_in: [String!]
  categoryName_not_in: [String!]
  categoryName_lt: String
  categoryName_lte: String
  categoryName_gt: String
  categoryName_gte: String
  categoryName_contains: String
  categoryName_not_contains: String
  categoryName_starts_with: String
  categoryName_not_starts_with: String
  categoryName_ends_with: String
  categoryName_not_ends_with: String
  product_every: ProductWhereInput
  product_some: ProductWhereInput
  product_none: ProductWhereInput
  superCategory: SuperCategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type Comment {
  id: ID!
  user: User!
  review: Review!
  text: String!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  user: UserCreateOneInput!
  review: ReviewCreateOneWithoutCommentsInput!
  text: String!
}

input CommentCreateManyWithoutReviewInput {
  create: [CommentCreateWithoutReviewInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutReviewInput {
  id: ID
  user: UserCreateOneInput!
  text: String!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  user: UserUpdateOneRequiredInput
  review: ReviewUpdateOneRequiredWithoutCommentsInput
  text: String
}

input CommentUpdateManyDataInput {
  text: String
}

input CommentUpdateManyMutationInput {
  text: String
}

input CommentUpdateManyWithoutReviewInput {
  create: [CommentCreateWithoutReviewInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutReviewDataInput {
  user: UserUpdateOneRequiredInput
  text: String
}

input CommentUpdateWithWhereUniqueWithoutReviewInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutReviewDataInput!
}

input CommentUpsertWithWhereUniqueWithoutReviewInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutReviewDataInput!
  create: CommentCreateWithoutReviewInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  review: ReviewWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Hate {
  id: ID!
  user: User
  review: Review
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HateConnection {
  pageInfo: PageInfo!
  edges: [HateEdge]!
  aggregate: AggregateHate!
}

input HateCreateInput {
  id: ID
  user: UserCreateOneWithoutMyHateInput
  review: ReviewCreateOneWithoutHatesInput
}

input HateCreateManyWithoutReviewInput {
  create: [HateCreateWithoutReviewInput!]
  connect: [HateWhereUniqueInput!]
}

input HateCreateManyWithoutUserInput {
  create: [HateCreateWithoutUserInput!]
  connect: [HateWhereUniqueInput!]
}

input HateCreateWithoutReviewInput {
  id: ID
  user: UserCreateOneWithoutMyHateInput
}

input HateCreateWithoutUserInput {
  id: ID
  review: ReviewCreateOneWithoutHatesInput
}

type HateEdge {
  node: Hate!
  cursor: String!
}

enum HateOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HatePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HateScalarWhereInput!]
  OR: [HateScalarWhereInput!]
  NOT: [HateScalarWhereInput!]
}

type HateSubscriptionPayload {
  mutation: MutationType!
  node: Hate
  updatedFields: [String!]
  previousValues: HatePreviousValues
}

input HateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HateWhereInput
  AND: [HateSubscriptionWhereInput!]
  OR: [HateSubscriptionWhereInput!]
  NOT: [HateSubscriptionWhereInput!]
}

input HateUpdateInput {
  user: UserUpdateOneWithoutMyHateInput
  review: ReviewUpdateOneWithoutHatesInput
}

input HateUpdateManyWithoutReviewInput {
  create: [HateCreateWithoutReviewInput!]
  delete: [HateWhereUniqueInput!]
  connect: [HateWhereUniqueInput!]
  set: [HateWhereUniqueInput!]
  disconnect: [HateWhereUniqueInput!]
  update: [HateUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [HateUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [HateScalarWhereInput!]
}

input HateUpdateManyWithoutUserInput {
  create: [HateCreateWithoutUserInput!]
  delete: [HateWhereUniqueInput!]
  connect: [HateWhereUniqueInput!]
  set: [HateWhereUniqueInput!]
  disconnect: [HateWhereUniqueInput!]
  update: [HateUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [HateUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [HateScalarWhereInput!]
}

input HateUpdateWithoutReviewDataInput {
  user: UserUpdateOneWithoutMyHateInput
}

input HateUpdateWithoutUserDataInput {
  review: ReviewUpdateOneWithoutHatesInput
}

input HateUpdateWithWhereUniqueWithoutReviewInput {
  where: HateWhereUniqueInput!
  data: HateUpdateWithoutReviewDataInput!
}

input HateUpdateWithWhereUniqueWithoutUserInput {
  where: HateWhereUniqueInput!
  data: HateUpdateWithoutUserDataInput!
}

input HateUpsertWithWhereUniqueWithoutReviewInput {
  where: HateWhereUniqueInput!
  update: HateUpdateWithoutReviewDataInput!
  create: HateCreateWithoutReviewInput!
}

input HateUpsertWithWhereUniqueWithoutUserInput {
  where: HateWhereUniqueInput!
  update: HateUpdateWithoutUserDataInput!
  create: HateCreateWithoutUserInput!
}

input HateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  review: ReviewWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HateWhereInput!]
  OR: [HateWhereInput!]
  NOT: [HateWhereInput!]
}

input HateWhereUniqueInput {
  id: ID
}

type Keyword {
  id: ID!
  search: String!
  count: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type KeywordConnection {
  pageInfo: PageInfo!
  edges: [KeywordEdge]!
  aggregate: AggregateKeyword!
}

input KeywordCreateInput {
  id: ID
  search: String!
  count: Int
}

input KeywordCreateManyInput {
  create: [KeywordCreateInput!]
  connect: [KeywordWhereUniqueInput!]
}

type KeywordEdge {
  node: Keyword!
  cursor: String!
}

enum KeywordOrderByInput {
  id_ASC
  id_DESC
  search_ASC
  search_DESC
  count_ASC
  count_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type KeywordPreviousValues {
  id: ID!
  search: String!
  count: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input KeywordScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  search: String
  search_not: String
  search_in: [String!]
  search_not_in: [String!]
  search_lt: String
  search_lte: String
  search_gt: String
  search_gte: String
  search_contains: String
  search_not_contains: String
  search_starts_with: String
  search_not_starts_with: String
  search_ends_with: String
  search_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [KeywordScalarWhereInput!]
  OR: [KeywordScalarWhereInput!]
  NOT: [KeywordScalarWhereInput!]
}

type KeywordSubscriptionPayload {
  mutation: MutationType!
  node: Keyword
  updatedFields: [String!]
  previousValues: KeywordPreviousValues
}

input KeywordSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: KeywordWhereInput
  AND: [KeywordSubscriptionWhereInput!]
  OR: [KeywordSubscriptionWhereInput!]
  NOT: [KeywordSubscriptionWhereInput!]
}

input KeywordUpdateDataInput {
  search: String
  count: Int
}

input KeywordUpdateInput {
  search: String
  count: Int
}

input KeywordUpdateManyDataInput {
  search: String
  count: Int
}

input KeywordUpdateManyInput {
  create: [KeywordCreateInput!]
  update: [KeywordUpdateWithWhereUniqueNestedInput!]
  upsert: [KeywordUpsertWithWhereUniqueNestedInput!]
  delete: [KeywordWhereUniqueInput!]
  connect: [KeywordWhereUniqueInput!]
  set: [KeywordWhereUniqueInput!]
  disconnect: [KeywordWhereUniqueInput!]
  deleteMany: [KeywordScalarWhereInput!]
  updateMany: [KeywordUpdateManyWithWhereNestedInput!]
}

input KeywordUpdateManyMutationInput {
  search: String
  count: Int
}

input KeywordUpdateManyWithWhereNestedInput {
  where: KeywordScalarWhereInput!
  data: KeywordUpdateManyDataInput!
}

input KeywordUpdateWithWhereUniqueNestedInput {
  where: KeywordWhereUniqueInput!
  data: KeywordUpdateDataInput!
}

input KeywordUpsertWithWhereUniqueNestedInput {
  where: KeywordWhereUniqueInput!
  update: KeywordUpdateDataInput!
  create: KeywordCreateInput!
}

input KeywordWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  search: String
  search_not: String
  search_in: [String!]
  search_not_in: [String!]
  search_lt: String
  search_lte: String
  search_gt: String
  search_gte: String
  search_contains: String
  search_not_contains: String
  search_starts_with: String
  search_not_starts_with: String
  search_ends_with: String
  search_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [KeywordWhereInput!]
  OR: [KeywordWhereInput!]
  NOT: [KeywordWhereInput!]
}

input KeywordWhereUniqueInput {
  id: ID
  search: String
}

type Like {
  id: ID!
  user: User
  review: Review
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LikeConnection {
  pageInfo: PageInfo!
  edges: [LikeEdge]!
  aggregate: AggregateLike!
}

input LikeCreateInput {
  id: ID
  user: UserCreateOneWithoutMyLikeInput
  review: ReviewCreateOneWithoutLikesInput
}

input LikeCreateManyWithoutReviewInput {
  create: [LikeCreateWithoutReviewInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutReviewInput {
  id: ID
  user: UserCreateOneWithoutMyLikeInput
}

input LikeCreateWithoutUserInput {
  id: ID
  review: ReviewCreateOneWithoutLikesInput
}

type LikeEdge {
  node: Like!
  cursor: String!
}

enum LikeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LikePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeScalarWhereInput!]
  OR: [LikeScalarWhereInput!]
  NOT: [LikeScalarWhereInput!]
}

type LikeSubscriptionPayload {
  mutation: MutationType!
  node: Like
  updatedFields: [String!]
  previousValues: LikePreviousValues
}

input LikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LikeWhereInput
  AND: [LikeSubscriptionWhereInput!]
  OR: [LikeSubscriptionWhereInput!]
  NOT: [LikeSubscriptionWhereInput!]
}

input LikeUpdateInput {
  user: UserUpdateOneWithoutMyLikeInput
  review: ReviewUpdateOneWithoutLikesInput
}

input LikeUpdateManyWithoutReviewInput {
  create: [LikeCreateWithoutReviewInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateWithoutReviewDataInput {
  user: UserUpdateOneWithoutMyLikeInput
}

input LikeUpdateWithoutUserDataInput {
  review: ReviewUpdateOneWithoutLikesInput
}

input LikeUpdateWithWhereUniqueWithoutReviewInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutReviewDataInput!
}

input LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutUserDataInput!
}

input LikeUpsertWithWhereUniqueWithoutReviewInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutReviewDataInput!
  create: LikeCreateWithoutReviewInput!
}

input LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutUserDataInput!
  create: LikeCreateWithoutUserInput!
}

input LikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  review: ReviewWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
}

input LikeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBlackList(data: BlackListCreateInput!): BlackList!
  updateBlackList(data: BlackListUpdateInput!, where: BlackListWhereUniqueInput!): BlackList
  updateManyBlackLists(data: BlackListUpdateManyMutationInput!, where: BlackListWhereInput): BatchPayload!
  upsertBlackList(where: BlackListWhereUniqueInput!, create: BlackListCreateInput!, update: BlackListUpdateInput!): BlackList!
  deleteBlackList(where: BlackListWhereUniqueInput!): BlackList
  deleteManyBlackLists(where: BlackListWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createHate(data: HateCreateInput!): Hate!
  updateHate(data: HateUpdateInput!, where: HateWhereUniqueInput!): Hate
  upsertHate(where: HateWhereUniqueInput!, create: HateCreateInput!, update: HateUpdateInput!): Hate!
  deleteHate(where: HateWhereUniqueInput!): Hate
  deleteManyHates(where: HateWhereInput): BatchPayload!
  createKeyword(data: KeywordCreateInput!): Keyword!
  updateKeyword(data: KeywordUpdateInput!, where: KeywordWhereUniqueInput!): Keyword
  updateManyKeywords(data: KeywordUpdateManyMutationInput!, where: KeywordWhereInput): BatchPayload!
  upsertKeyword(where: KeywordWhereUniqueInput!, create: KeywordCreateInput!, update: KeywordUpdateInput!): Keyword!
  deleteKeyword(where: KeywordWhereUniqueInput!): Keyword
  deleteManyKeywords(where: KeywordWhereInput): BatchPayload!
  createLike(data: LikeCreateInput!): Like!
  updateLike(data: LikeUpdateInput!, where: LikeWhereUniqueInput!): Like
  upsertLike(where: LikeWhereUniqueInput!, create: LikeCreateInput!, update: LikeUpdateInput!): Like!
  deleteLike(where: LikeWhereUniqueInput!): Like
  deleteManyLikes(where: LikeWhereInput): BatchPayload!
  createPhoto(data: PhotoCreateInput!): Photo!
  updatePhoto(data: PhotoUpdateInput!, where: PhotoWhereUniqueInput!): Photo
  updateManyPhotos(data: PhotoUpdateManyMutationInput!, where: PhotoWhereInput): BatchPayload!
  upsertPhoto(where: PhotoWhereUniqueInput!, create: PhotoCreateInput!, update: PhotoUpdateInput!): Photo!
  deletePhoto(where: PhotoWhereUniqueInput!): Photo
  deleteManyPhotos(where: PhotoWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createSuperCategory(data: SuperCategoryCreateInput!): SuperCategory!
  updateSuperCategory(data: SuperCategoryUpdateInput!, where: SuperCategoryWhereUniqueInput!): SuperCategory
  updateManySuperCategories(data: SuperCategoryUpdateManyMutationInput!, where: SuperCategoryWhereInput): BatchPayload!
  upsertSuperCategory(where: SuperCategoryWhereUniqueInput!, create: SuperCategoryCreateInput!, update: SuperCategoryUpdateInput!): SuperCategory!
  deleteSuperCategory(where: SuperCategoryWhereUniqueInput!): SuperCategory
  deleteManySuperCategories(where: SuperCategoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Photo {
  id: ID!
  url: String!
  review: Review
  product: Product
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoConnection {
  pageInfo: PageInfo!
  edges: [PhotoEdge]!
  aggregate: AggregatePhoto!
}

input PhotoCreateInput {
  id: ID
  url: String!
  review: ReviewCreateOneWithoutReviewPhotosInput
  product: ProductCreateOneWithoutProductPhotosInput
}

input PhotoCreateManyWithoutProductInput {
  create: [PhotoCreateWithoutProductInput!]
  connect: [PhotoWhereUniqueInput!]
}

input PhotoCreateManyWithoutReviewInput {
  create: [PhotoCreateWithoutReviewInput!]
  connect: [PhotoWhereUniqueInput!]
}

input PhotoCreateWithoutProductInput {
  id: ID
  url: String!
  review: ReviewCreateOneWithoutReviewPhotosInput
}

input PhotoCreateWithoutReviewInput {
  id: ID
  url: String!
  product: ProductCreateOneWithoutProductPhotosInput
}

type PhotoEdge {
  node: Photo!
  cursor: String!
}

enum PhotoOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhotoPreviousValues {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhotoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoScalarWhereInput!]
  OR: [PhotoScalarWhereInput!]
  NOT: [PhotoScalarWhereInput!]
}

type PhotoSubscriptionPayload {
  mutation: MutationType!
  node: Photo
  updatedFields: [String!]
  previousValues: PhotoPreviousValues
}

input PhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhotoWhereInput
  AND: [PhotoSubscriptionWhereInput!]
  OR: [PhotoSubscriptionWhereInput!]
  NOT: [PhotoSubscriptionWhereInput!]
}

input PhotoUpdateInput {
  url: String
  review: ReviewUpdateOneWithoutReviewPhotosInput
  product: ProductUpdateOneWithoutProductPhotosInput
}

input PhotoUpdateManyDataInput {
  url: String
}

input PhotoUpdateManyMutationInput {
  url: String
}

input PhotoUpdateManyWithoutProductInput {
  create: [PhotoCreateWithoutProductInput!]
  delete: [PhotoWhereUniqueInput!]
  connect: [PhotoWhereUniqueInput!]
  set: [PhotoWhereUniqueInput!]
  disconnect: [PhotoWhereUniqueInput!]
  update: [PhotoUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [PhotoUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [PhotoScalarWhereInput!]
  updateMany: [PhotoUpdateManyWithWhereNestedInput!]
}

input PhotoUpdateManyWithoutReviewInput {
  create: [PhotoCreateWithoutReviewInput!]
  delete: [PhotoWhereUniqueInput!]
  connect: [PhotoWhereUniqueInput!]
  set: [PhotoWhereUniqueInput!]
  disconnect: [PhotoWhereUniqueInput!]
  update: [PhotoUpdateWithWhereUniqueWithoutReviewInput!]
  upsert: [PhotoUpsertWithWhereUniqueWithoutReviewInput!]
  deleteMany: [PhotoScalarWhereInput!]
  updateMany: [PhotoUpdateManyWithWhereNestedInput!]
}

input PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput!
  data: PhotoUpdateManyDataInput!
}

input PhotoUpdateWithoutProductDataInput {
  url: String
  review: ReviewUpdateOneWithoutReviewPhotosInput
}

input PhotoUpdateWithoutReviewDataInput {
  url: String
  product: ProductUpdateOneWithoutProductPhotosInput
}

input PhotoUpdateWithWhereUniqueWithoutProductInput {
  where: PhotoWhereUniqueInput!
  data: PhotoUpdateWithoutProductDataInput!
}

input PhotoUpdateWithWhereUniqueWithoutReviewInput {
  where: PhotoWhereUniqueInput!
  data: PhotoUpdateWithoutReviewDataInput!
}

input PhotoUpsertWithWhereUniqueWithoutProductInput {
  where: PhotoWhereUniqueInput!
  update: PhotoUpdateWithoutProductDataInput!
  create: PhotoCreateWithoutProductInput!
}

input PhotoUpsertWithWhereUniqueWithoutReviewInput {
  where: PhotoWhereUniqueInput!
  update: PhotoUpdateWithoutReviewDataInput!
  create: PhotoCreateWithoutReviewInput!
}

input PhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  review: ReviewWhereInput
  product: ProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoWhereInput!]
  OR: [PhotoWhereInput!]
  NOT: [PhotoWhereInput!]
}

input PhotoWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  user: User
  productName: String!
  category: Category!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  productPhotos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo!]
  isPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  user: UserCreateOneWithoutMyProductInput
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  reviews: ReviewCreateManyWithoutProductInput
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutUserInput {
  create: [ProductCreateWithoutUserInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneWithoutProductPhotosInput {
  create: ProductCreateWithoutProductPhotosInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutReviewsInput {
  create: ProductCreateWithoutReviewsInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutCategoryInput {
  id: ID
  user: UserCreateOneWithoutMyProductInput
  productName: String!
  reviews: ReviewCreateManyWithoutProductInput
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateWithoutProductPhotosInput {
  id: ID
  user: UserCreateOneWithoutMyProductInput
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  reviews: ReviewCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateWithoutReviewsInput {
  id: ID
  user: UserCreateOneWithoutMyProductInput
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

input ProductCreateWithoutUserInput {
  id: ID
  productName: String!
  category: CategoryCreateOneWithoutProductInput!
  reviews: ReviewCreateManyWithoutProductInput
  productPhotos: PhotoCreateManyWithoutProductInput
  isPublished: Boolean
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  productName_ASC
  productName_DESC
  isPublished_ASC
  isPublished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  productName: String!
  isPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  user: UserUpdateOneWithoutMyProductInput
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  reviews: ReviewUpdateManyWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateManyDataInput {
  productName: String
  isPublished: Boolean
}

input ProductUpdateManyMutationInput {
  productName: String
  isPublished: Boolean
}

input ProductUpdateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutUserInput {
  create: [ProductCreateWithoutUserInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredWithoutReviewsInput {
  create: ProductCreateWithoutReviewsInput
  update: ProductUpdateWithoutReviewsDataInput
  upsert: ProductUpsertWithoutReviewsInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneWithoutProductPhotosInput {
  create: ProductCreateWithoutProductPhotosInput
  update: ProductUpdateWithoutProductPhotosDataInput
  upsert: ProductUpsertWithoutProductPhotosInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutCategoryDataInput {
  user: UserUpdateOneWithoutMyProductInput
  productName: String
  reviews: ReviewUpdateManyWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithoutProductPhotosDataInput {
  user: UserUpdateOneWithoutMyProductInput
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  reviews: ReviewUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithoutReviewsDataInput {
  user: UserUpdateOneWithoutMyProductInput
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithoutUserDataInput {
  productName: String
  category: CategoryUpdateOneRequiredWithoutProductInput
  reviews: ReviewUpdateManyWithoutProductInput
  productPhotos: PhotoUpdateManyWithoutProductInput
  isPublished: Boolean
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCategoryDataInput!
}

input ProductUpdateWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutUserDataInput!
}

input ProductUpsertWithoutProductPhotosInput {
  update: ProductUpdateWithoutProductPhotosDataInput!
  create: ProductCreateWithoutProductPhotosInput!
}

input ProductUpsertWithoutReviewsInput {
  update: ProductUpdateWithoutReviewsDataInput!
  create: ProductCreateWithoutReviewsInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCategoryDataInput!
  create: ProductCreateWithoutCategoryInput!
}

input ProductUpsertWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutUserDataInput!
  create: ProductCreateWithoutUserInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  productName: String
  productName_not: String
  productName_in: [String!]
  productName_not_in: [String!]
  productName_lt: String
  productName_lte: String
  productName_gt: String
  productName_gte: String
  productName_contains: String
  productName_not_contains: String
  productName_starts_with: String
  productName_not_starts_with: String
  productName_ends_with: String
  productName_not_ends_with: String
  category: CategoryWhereInput
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  productPhotos_every: PhotoWhereInput
  productPhotos_some: PhotoWhereInput
  productPhotos_none: PhotoWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
  productName: String
}

type Query {
  blackList(where: BlackListWhereUniqueInput!): BlackList
  blackLists(where: BlackListWhereInput, orderBy: BlackListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BlackList]!
  blackListsConnection(where: BlackListWhereInput, orderBy: BlackListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BlackListConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  hate(where: HateWhereUniqueInput!): Hate
  hates(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate]!
  hatesConnection(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HateConnection!
  keyword(where: KeywordWhereUniqueInput!): Keyword
  keywords(where: KeywordWhereInput, orderBy: KeywordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Keyword]!
  keywordsConnection(where: KeywordWhereInput, orderBy: KeywordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): KeywordConnection!
  like(where: LikeWhereUniqueInput!): Like
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like]!
  likesConnection(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LikeConnection!
  photo(where: PhotoWhereUniqueInput!): Photo
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo]!
  photosConnection(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhotoConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  superCategory(where: SuperCategoryWhereUniqueInput!): SuperCategory
  superCategories(where: SuperCategoryWhereInput, orderBy: SuperCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SuperCategory]!
  superCategoriesConnection(where: SuperCategoryWhereInput, orderBy: SuperCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SuperCategoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  user: User!
  title: String
  product: Product!
  text: String!
  rating: Float!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  hates(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate!]
  reviewPhotos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateManyWithoutProductInput {
  create: [ReviewCreateWithoutProductInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutUserInput {
  create: [ReviewCreateWithoutUserInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateOneWithoutCommentsInput {
  create: ReviewCreateWithoutCommentsInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateOneWithoutHatesInput {
  create: ReviewCreateWithoutHatesInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateOneWithoutLikesInput {
  create: ReviewCreateWithoutLikesInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateOneWithoutReviewPhotosInput {
  create: ReviewCreateWithoutReviewPhotosInput
  connect: ReviewWhereUniqueInput
}

input ReviewCreateWithoutCommentsInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutHatesInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  likes: LikeCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutLikesInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutProductInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

input ReviewCreateWithoutReviewPhotosInput {
  id: ID
  user: UserCreateOneWithoutMyReviewInput!
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
}

input ReviewCreateWithoutUserInput {
  id: ID
  title: String
  product: ProductCreateOneWithoutReviewsInput!
  text: String!
  rating: Float!
  comments: CommentCreateManyWithoutReviewInput
  likes: LikeCreateManyWithoutReviewInput
  hates: HateCreateManyWithoutReviewInput
  reviewPhotos: PhotoCreateManyWithoutReviewInput
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  rating_ASC
  rating_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReviewPreviousValues {
  id: ID!
  title: String
  text: String!
  rating: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateManyDataInput {
  title: String
  text: String
  rating: Float
}

input ReviewUpdateManyMutationInput {
  title: String
  text: String
  rating: Float
}

input ReviewUpdateManyWithoutProductInput {
  create: [ReviewCreateWithoutProductInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithoutUserInput {
  create: [ReviewCreateWithoutUserInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateOneRequiredWithoutCommentsInput {
  create: ReviewCreateWithoutCommentsInput
  update: ReviewUpdateWithoutCommentsDataInput
  upsert: ReviewUpsertWithoutCommentsInput
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateOneWithoutHatesInput {
  create: ReviewCreateWithoutHatesInput
  update: ReviewUpdateWithoutHatesDataInput
  upsert: ReviewUpsertWithoutHatesInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateOneWithoutLikesInput {
  create: ReviewCreateWithoutLikesInput
  update: ReviewUpdateWithoutLikesDataInput
  upsert: ReviewUpsertWithoutLikesInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateOneWithoutReviewPhotosInput {
  create: ReviewCreateWithoutReviewPhotosInput
  update: ReviewUpdateWithoutReviewPhotosDataInput
  upsert: ReviewUpsertWithoutReviewPhotosInput
  delete: Boolean
  disconnect: Boolean
  connect: ReviewWhereUniqueInput
}

input ReviewUpdateWithoutCommentsDataInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutHatesDataInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  likes: LikeUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutLikesDataInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutProductDataInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutReviewPhotosDataInput {
  user: UserUpdateOneRequiredWithoutMyReviewInput
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
}

input ReviewUpdateWithoutUserDataInput {
  title: String
  product: ProductUpdateOneRequiredWithoutReviewsInput
  text: String
  rating: Float
  comments: CommentUpdateManyWithoutReviewInput
  likes: LikeUpdateManyWithoutReviewInput
  hates: HateUpdateManyWithoutReviewInput
  reviewPhotos: PhotoUpdateManyWithoutReviewInput
}

input ReviewUpdateWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutProductDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutUserDataInput!
}

input ReviewUpsertWithoutCommentsInput {
  update: ReviewUpdateWithoutCommentsDataInput!
  create: ReviewCreateWithoutCommentsInput!
}

input ReviewUpsertWithoutHatesInput {
  update: ReviewUpdateWithoutHatesDataInput!
  create: ReviewCreateWithoutHatesInput!
}

input ReviewUpsertWithoutLikesInput {
  update: ReviewUpdateWithoutLikesDataInput!
  create: ReviewCreateWithoutLikesInput!
}

input ReviewUpsertWithoutReviewPhotosInput {
  update: ReviewUpdateWithoutReviewPhotosDataInput!
  create: ReviewCreateWithoutReviewPhotosInput!
}

input ReviewUpsertWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutProductDataInput!
  create: ReviewCreateWithoutProductInput!
}

input ReviewUpsertWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutUserDataInput!
  create: ReviewCreateWithoutUserInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  product: ProductWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likes_every: LikeWhereInput
  likes_some: LikeWhereInput
  likes_none: LikeWhereInput
  hates_every: HateWhereInput
  hates_some: HateWhereInput
  hates_none: HateWhereInput
  reviewPhotos_every: PhotoWhereInput
  reviewPhotos_some: PhotoWhereInput
  reviewPhotos_none: PhotoWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Subscription {
  blackList(where: BlackListSubscriptionWhereInput): BlackListSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  hate(where: HateSubscriptionWhereInput): HateSubscriptionPayload
  keyword(where: KeywordSubscriptionWhereInput): KeywordSubscriptionPayload
  like(where: LikeSubscriptionWhereInput): LikeSubscriptionPayload
  photo(where: PhotoSubscriptionWhereInput): PhotoSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  superCategory(where: SuperCategorySubscriptionWhereInput): SuperCategorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type SuperCategory {
  id: ID!
  superCategoryName: String!
  category(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SuperCategoryConnection {
  pageInfo: PageInfo!
  edges: [SuperCategoryEdge]!
  aggregate: AggregateSuperCategory!
}

input SuperCategoryCreateInput {
  id: ID
  superCategoryName: String!
  category: CategoryCreateManyWithoutSuperCategoryInput
}

input SuperCategoryCreateOneWithoutCategoryInput {
  create: SuperCategoryCreateWithoutCategoryInput
  connect: SuperCategoryWhereUniqueInput
}

input SuperCategoryCreateWithoutCategoryInput {
  id: ID
  superCategoryName: String!
}

type SuperCategoryEdge {
  node: SuperCategory!
  cursor: String!
}

enum SuperCategoryOrderByInput {
  id_ASC
  id_DESC
  superCategoryName_ASC
  superCategoryName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SuperCategoryPreviousValues {
  id: ID!
  superCategoryName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SuperCategorySubscriptionPayload {
  mutation: MutationType!
  node: SuperCategory
  updatedFields: [String!]
  previousValues: SuperCategoryPreviousValues
}

input SuperCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SuperCategoryWhereInput
  AND: [SuperCategorySubscriptionWhereInput!]
  OR: [SuperCategorySubscriptionWhereInput!]
  NOT: [SuperCategorySubscriptionWhereInput!]
}

input SuperCategoryUpdateInput {
  superCategoryName: String
  category: CategoryUpdateManyWithoutSuperCategoryInput
}

input SuperCategoryUpdateManyMutationInput {
  superCategoryName: String
}

input SuperCategoryUpdateOneWithoutCategoryInput {
  create: SuperCategoryCreateWithoutCategoryInput
  update: SuperCategoryUpdateWithoutCategoryDataInput
  upsert: SuperCategoryUpsertWithoutCategoryInput
  delete: Boolean
  disconnect: Boolean
  connect: SuperCategoryWhereUniqueInput
}

input SuperCategoryUpdateWithoutCategoryDataInput {
  superCategoryName: String
}

input SuperCategoryUpsertWithoutCategoryInput {
  update: SuperCategoryUpdateWithoutCategoryDataInput!
  create: SuperCategoryCreateWithoutCategoryInput!
}

input SuperCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  superCategoryName: String
  superCategoryName_not: String
  superCategoryName_in: [String!]
  superCategoryName_not_in: [String!]
  superCategoryName_lt: String
  superCategoryName_lte: String
  superCategoryName_gt: String
  superCategoryName_gte: String
  superCategoryName_contains: String
  superCategoryName_not_contains: String
  superCategoryName_starts_with: String
  superCategoryName_not_starts_with: String
  superCategoryName_ends_with: String
  superCategoryName_not_ends_with: String
  category_every: CategoryWhereInput
  category_some: CategoryWhereInput
  category_none: CategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SuperCategoryWhereInput!]
  OR: [SuperCategoryWhereInput!]
  NOT: [SuperCategoryWhereInput!]
}

input SuperCategoryWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword(where: KeywordWhereInput, orderBy: KeywordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Keyword!]
  password: String!
  myReview(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  myProduct(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  myLike(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  myHate(where: HateWhereInput, orderBy: HateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hate!]
  loginSecret: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword: KeywordCreateManyInput
  password: String!
  myReview: ReviewCreateManyWithoutUserInput
  myProduct: ProductCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyHateInput {
  create: UserCreateWithoutMyHateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyLikeInput {
  create: UserCreateWithoutMyLikeInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyProductInput {
  create: UserCreateWithoutMyProductInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyReviewInput {
  create: UserCreateWithoutMyReviewInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutMyHateInput {
  id: ID
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword: KeywordCreateManyInput
  password: String!
  myReview: ReviewCreateManyWithoutUserInput
  myProduct: ProductCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateWithoutMyLikeInput {
  id: ID
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword: KeywordCreateManyInput
  password: String!
  myReview: ReviewCreateManyWithoutUserInput
  myProduct: ProductCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateWithoutMyProductInput {
  id: ID
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword: KeywordCreateManyInput
  password: String!
  myReview: ReviewCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

input UserCreateWithoutMyReviewInput {
  id: ID
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  keyword: KeywordCreateManyInput
  password: String!
  myProduct: ProductCreateManyWithoutUserInput
  myLike: LikeCreateManyWithoutUserInput
  myHate: HateCreateManyWithoutUserInput
  loginSecret: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  avatar_ASC
  avatar_DESC
  nickName_ASC
  nickName_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  loginSecret_ASC
  loginSecret_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  avatar: String
  nickName: String!
  phone: String!
  email: String!
  password: String!
  loginSecret: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myReview: ReviewUpdateManyWithoutUserInput
  myProduct: ProductUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myReview: ReviewUpdateManyWithoutUserInput
  myProduct: ProductUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateManyMutationInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  password: String
  loginSecret: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutMyReviewInput {
  create: UserCreateWithoutMyReviewInput
  update: UserUpdateWithoutMyReviewDataInput
  upsert: UserUpsertWithoutMyReviewInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMyHateInput {
  create: UserCreateWithoutMyHateInput
  update: UserUpdateWithoutMyHateDataInput
  upsert: UserUpsertWithoutMyHateInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMyLikeInput {
  create: UserCreateWithoutMyLikeInput
  update: UserUpdateWithoutMyLikeDataInput
  upsert: UserUpsertWithoutMyLikeInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutMyProductInput {
  create: UserCreateWithoutMyProductInput
  update: UserUpdateWithoutMyProductDataInput
  upsert: UserUpsertWithoutMyProductInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutMyHateDataInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myReview: ReviewUpdateManyWithoutUserInput
  myProduct: ProductUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateWithoutMyLikeDataInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myReview: ReviewUpdateManyWithoutUserInput
  myProduct: ProductUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateWithoutMyProductDataInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myReview: ReviewUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpdateWithoutMyReviewDataInput {
  avatar: String
  nickName: String
  phone: String
  email: String
  keyword: KeywordUpdateManyInput
  password: String
  myProduct: ProductUpdateManyWithoutUserInput
  myLike: LikeUpdateManyWithoutUserInput
  myHate: HateUpdateManyWithoutUserInput
  loginSecret: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutMyHateInput {
  update: UserUpdateWithoutMyHateDataInput!
  create: UserCreateWithoutMyHateInput!
}

input UserUpsertWithoutMyLikeInput {
  update: UserUpdateWithoutMyLikeDataInput!
  create: UserCreateWithoutMyLikeInput!
}

input UserUpsertWithoutMyProductInput {
  update: UserUpdateWithoutMyProductDataInput!
  create: UserCreateWithoutMyProductInput!
}

input UserUpsertWithoutMyReviewInput {
  update: UserUpdateWithoutMyReviewDataInput!
  create: UserCreateWithoutMyReviewInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  nickName: String
  nickName_not: String
  nickName_in: [String!]
  nickName_not_in: [String!]
  nickName_lt: String
  nickName_lte: String
  nickName_gt: String
  nickName_gte: String
  nickName_contains: String
  nickName_not_contains: String
  nickName_starts_with: String
  nickName_not_starts_with: String
  nickName_ends_with: String
  nickName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  keyword_every: KeywordWhereInput
  keyword_some: KeywordWhereInput
  keyword_none: KeywordWhereInput
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  myReview_every: ReviewWhereInput
  myReview_some: ReviewWhereInput
  myReview_none: ReviewWhereInput
  myProduct_every: ProductWhereInput
  myProduct_some: ProductWhereInput
  myProduct_none: ProductWhereInput
  myLike_every: LikeWhereInput
  myLike_some: LikeWhereInput
  myLike_none: LikeWhereInput
  myHate_every: HateWhereInput
  myHate_some: HateWhereInput
  myHate_none: HateWhereInput
  loginSecret: String
  loginSecret_not: String
  loginSecret_in: [String!]
  loginSecret_not_in: [String!]
  loginSecret_lt: String
  loginSecret_lte: String
  loginSecret_gt: String
  loginSecret_gte: String
  loginSecret_contains: String
  loginSecret_not_contains: String
  loginSecret_starts_with: String
  loginSecret_not_starts_with: String
  loginSecret_ends_with: String
  loginSecret_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  nickName: String
  phone: String
  email: String
}
`
      }
    